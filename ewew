#include <iostream>
#include <cstring>
#include <fstream>
#include <cctype>

using namespace std;


template <class Type>
class Stack {
Type* arr;
int head,tail, size, maxsize;
public :
   Stack () ;
   void push ( Type sym ) ;
   Type pop();
   int Size();
   void resize(int maxsize);
   Type Top();
} ;
//----------------

template <class Type>
Stack<Type>::Stack()
{
   arr = new char[100];
   head = size = 0 ;
   tail= -1;
   maxsize = 100;
}
//----------------

template <class Type>
void Stack<Type>::push (Type sym){
    if (size == maxsize){
        resize(2*maxsize);

    }

        tail++;
        size++;
        arr[tail] = sym;
}
//----------------
template <class Type>
Type Stack<Type>::pop(){
    char x;
    x = arr[tail];
        tail--;
        size--;
        return(x);
}

//----------------

template <class Type>
int Stack<Type>::Size(){
    return (size);
}


template <class Type>
void Stack<Type>::resize(int new_size){
    Type* new_arr = new Type[new_size];
    int i;
    for (i = 0; i < size; i++){
        new_arr[i] = arr[i];
    }
    delete[] arr;
    maxsize = new_size;
    arr = new_arr;

}

template <class Type>
Type Stack<Type>::Top(){
    return(arr[tail]);

}


int prioritet(char ch){
    switch(ch){
        case '+': case'-':{
            return 1;
        }
        case '*': case '/':{
            return 2;
        }
        case '^':{
             return 3;
        }
    default:{
        return 0;
    }

    }
}

bool isOperation(char x){
    if (x == '^' || x == '*' || x == '/' || x == '+' || x == '-')
        return true;
    return false;
}




int main(){ //A*B+C*D = +*AB*CD   C+D*E+Q = ++C*DEQ  (A+B*C)*D =
        int i = 0;
        const char space = ' ';
        string ans;
        string infix;
        Stack <char> operations;
        //ifstream infile("infix.txt");
        getline(cin, infix);
        if(!isalpha(infix[i]) && !isdigit(infix[i])){ 
            cout<<"Неверное инфиксное выражение - первый символ не переменная и не число"<<endl;
            return 0;
        }
       // infile.close();
        i = infix.length() - 1;
        if(!isalpha(infix[i]) && !isdigit(infix[i])){ 
            cout<<"Неверное инфиксное выражение - операция в конце строки"<<endl;
            return 0;
        }
        while (i >= 0){

            if(isalpha(infix[i]) || isdigit(infix[i])){
                ans.insert(0, 1, infix[i]);
                if(!isalpha(infix[i-1]) && !(isdigit(infix[i-1])))
                     ans.insert(0, 1, space);

            }
            else if (isOperation(infix[i])){
                if (isOperation(infix[i-1])){
                    cout<<"Неверное инфиксное выражение - два знака подряд"<<endl;
                    return 0;
                }
                if(!operations.Size())
                    operations.push(infix[i]);
                else{
                    while(prioritet(infix[i]) <= prioritet(operations.Top()) && operations.Size()){
                        ans.insert(0, 1, operations.pop());
                        ans.insert(0, 1, space);
                    }
                    operations.push(infix[i]);
                }

            }
          else if(infix[i] ==')'){
                operations.push(infix[i]);
            }
          else if(infix[i] =='('){
               while (prioritet(operations.Top())){

                  ans.insert(0, 1, operations.pop());
                  ans.insert(0, 1, space);

               }
               if (operations.Top() != ')'){
                   cout<<"Нет закрывающей скобки!";
                   return 0;
               }
               operations.pop();
            }


            else{
                cout<<"Лишние символы"<<endl;
                return 0;
            }
            i--;
        }
        while(operations.Size()){
            ans.insert(0, 1, operations.pop());
            ans.insert(0, 1, space);
        }
        //ofstream out("prefix.txt");
        //out<<ans;
        //cout<<"Выражение записано в префиксном форме"<<endl;
        //out.close();
        cout<<ans;
        ans.clear();
        infix.clear();
        return 0;
        

}
